(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(o){if(o.ep)return;o.ep=!0;const i=e(o);fetch(o.href,i)}})();const vt=`(ns clojure.core)

(defmacro defn [name params & body]
  \`(def ~name (fn ~params ~@body)))

(defn next [coll]
  (seq (rest coll)))

(defmacro when [condition & body]
  \`(if ~condition (do ~@body) nil))

(defmacro when-not [condition & body]
  \`(if ~condition nil (do ~@body)))

(defmacro and [& forms]
  (if (nil? forms)
    true
    (if (nil? (seq (rest forms)))
      (first forms)
      \`(let [__v ~(first forms)]
         (if __v (and ~@(rest forms)) __v)))))

(defmacro or [& forms]
  (if (nil? forms)
    nil
    (if (nil? (seq (rest forms)))
      (first forms)
      \`(let [__v ~(first forms)]
         (if __v __v (or ~@(rest forms)))))))

(defmacro cond [& clauses]
  (if (nil? clauses)
    nil
    \`(if ~(first clauses)
       ~(first (next clauses))
       (cond ~@(rest (rest clauses))))))

(defmacro -> [x & forms]
  (if (nil? forms)
    x
    (let [form (first forms)
          more (rest forms)
          threaded (if (list? form)
                     \`(~(first form) ~x ~@(rest form))
                     \`(~form ~x))]
      \`(-> ~threaded ~@more))))

(defmacro ->> [x & forms]
  (if (nil? forms)
    x
    (let [form (first forms)
          more (rest forms)
          threaded (if (list? form)
                     \`(~(first form) ~@(rest form) ~x)
                     \`(~form ~x))]
      \`(->> ~threaded ~@more))))
`;class Pe extends Error{context;constructor(r,e){super(r),this.context=e,this.name="EnvError"}}function X(t){return{bindings:new Map,outer:t??null}}function W(t,r){let e=r;for(;e;){if(e.bindings.has(t))return e.bindings.get(t);e=e.outer}throw new Error(`Symbol ${t} not found`)}function _(t,r,e){e.bindings.set(t,r)}function O(t,r,e){if(t.length!==r.length)throw new Pe("Number of parameters and arguments must match",{params:t,args:r,outer:e});const n=X(e);for(let o=0;o<t.length;o++)_(t[o],r[o],n);return n}function de(t){let r=t;for(;r?.outer;)r=r.outer;return r}function me(t){let r=t;for(;r;){if(r.namespace)return r;r=r.outer}return de(t)}const B=t=>({kind:"number",value:t}),Ue=t=>({kind:"string",value:t}),v=t=>({kind:"boolean",value:t}),Be=t=>({kind:"keyword",name:t}),E=()=>({kind:"nil",value:null}),H=t=>({kind:"symbol",name:t}),j=t=>({kind:"list",value:t}),P=t=>({kind:"vector",value:t}),L=t=>({kind:"map",entries:t}),Ne=(t,r)=>({kind:"function",arities:t,env:r}),f=(t,r)=>({kind:"native-function",name:t,fn:r}),Fe=(t,r)=>({kind:"macro",arities:t,env:r}),u={number:"number",string:"string",boolean:"boolean",keyword:"keyword",nil:"nil",symbol:"symbol",list:"list",vector:"vector",map:"map",function:"function",nativeFunction:"native-function",macro:"macro"},m={LParen:"LParen",RParen:"RParen",LBracket:"LBracket",RBracket:"RBracket",LBrace:"LBrace",RBrace:"RBrace",String:"String",Number:"Number",Keyword:"Keyword",Quote:"Quote",Quasiquote:"Quasiquote",Unquote:"Unquote",UnquoteSplicing:"UnquoteSplicing",Comment:"Comment",Whitespace:"Whitespace",Symbol:"Symbol"},A={Quote:"quote",Quasiquote:"quasiquote",Unquote:"unquote",UnquoteSplicing:"unquote-splicing",LParen:"(",RParen:")",LBracket:"[",RBracket:"]",LBrace:"{",RBrace:"}"},oe=t=>t.kind==="nil"?!0:t.kind==="boolean"?!t.value:!1,te=t=>!oe(t),Re=t=>t.kind==="symbol"&&t.name in Me,S=t=>t.kind==="symbol",$=t=>t.kind==="vector",y=t=>t.kind==="list",Ae=t=>t.kind==="function",Le=t=>t.kind==="native-function",ne=t=>t.kind==="macro",U=t=>t.kind==="map",Z=t=>t.kind==="keyword",Q=t=>Ae(t)||Le(t),q=t=>$(t)||U(t)||y(t),kt=t=>typeof t=="object"&&t!==null&&"kind"in t&&t.kind in u,Ce={[u.number]:(t,r)=>t.value===r.value,[u.string]:(t,r)=>t.value===r.value,[u.boolean]:(t,r)=>t.value===r.value,[u.nil]:()=>!0,[u.symbol]:(t,r)=>t.name===r.name,[u.keyword]:(t,r)=>t.name===r.name,[u.vector]:(t,r)=>t.value.length!==r.value.length?!1:t.value.every((e,n)=>F(e,r.value[n])),[u.map]:(t,r)=>{if(t.entries.length!==r.entries.length)return!1;const e=new Set([...t.entries.map(([n])=>n),...r.entries.map(([n])=>n)]);for(const n of e){const o=t.entries.find(([a])=>F(a,n));if(!o)return!1;const i=r.entries.find(([a])=>F(a,n));if(!i||!F(o[1],i[1]))return!1}return!0},[u.list]:(t,r)=>t.value.length!==r.value.length?!1:t.value.every((e,n)=>F(e,r.value[n]))},F=(t,r)=>{if(t.kind!==r.kind)return!1;const e=Ce[t.kind];return e?e(t,r):!1},Me={quote:"quote",def:"def",if:"if",do:"do",let:"let",fn:"fn",defmacro:"defmacro",quasiquote:"quasiquote",ns:"ns",loop:"loop",recur:"recur"};class s extends Error{context;constructor(r,e){super(r),this.name="EvaluationError",this.context=e}}class D{args;constructor(r){this.args=r}}function ae(t,r){const e=t.value.findIndex(i=>S(i)&&i.name==="&");let n=[],o=null;if(e===-1)n=t.value.map(i=>i);else{if(t.value.filter(a=>S(a)&&a.name==="&").length>1)throw new s("& can only appear once",{args:t,env:r});if(e!==t.value.length-2)throw new s("& must be second-to-last argument",{args:t,env:r});n=t.value.slice(0,e).map(a=>a),o=t.value[e+1]}return{params:n,restParam:o}}function ue(t,r){if(t.length===0)throw new s("fn/defmacro requires at least a parameter vector",{forms:t,env:r});if($(t[0])){const e=t[0];if(e.value.some(i=>!S(i)))throw new s("Parameters must be symbols",{paramVec:e,env:r});const{params:n,restParam:o}=ae(e,r);return[{params:n,restParam:o,body:t.slice(1)}]}if(y(t[0])){const e=[];for(const o of t){if(!y(o)||o.value.length===0)throw new s("Multi-arity clause must be a list starting with a parameter vector",{form:o,env:r});const i=o.value[0];if(!$(i))throw new s("First element of arity clause must be a parameter vector",{paramVec:i,env:r});if(i.value.some(l=>!S(l)))throw new s("Parameters must be symbols",{paramVec:i,env:r});const{params:a,restParam:c}=ae(i,r);e.push({params:a,restParam:c,body:o.value.slice(1)})}if(e.filter(o=>o.restParam!==null).length>1)throw new s("At most one variadic arity is allowed per function",{forms:t,env:r});return e}throw new s("fn/defmacro expects a parameter vector or arity clauses",{forms:t,env:r})}function pe(t,r,e,n){const o=t.map(a=>a.name),i=e.slice(0,o.length);if(r===null){if(e.length!==t.length)throw new s(`Arguments length mismatch: fn accepts ${t.length} arguments, but ${e.length} were provided`,{params:t,args:e,outerEnv:n})}else{if(e.length<t.length)throw new s(`Arguments length mismatch: fn expects at least ${t.length} arguments, but ${e.length} were provided`,{params:t,args:e,outerEnv:n});const a=e.slice(o.length),c=a.length>0?j(a):E();return o.push(r.name),i.push(c),O(o,i,n)}return O(o,i,n)}function he(t,r){const e=t.find(i=>i.restParam===null&&i.params.length===r);if(e)return e;const n=t.find(i=>i.restParam!==null&&r>=i.params.length);if(n)return n;const o=t.map(i=>i.restParam?`${i.params.length}+`:`${i.params.length}`);throw new s(`No matching arity for ${r} arguments. Available arities: ${o.join(", ")}`,{arities:t,argCount:r})}function I(t,r,e){if(t.kind==="native-function")return t.fn(...r);if(t.kind==="function"){const n=he(t.arities,r.length);let o=r;for(;;){const i=pe(n.params,n.restParam,o,t.env);try{return K(n.body,i)}catch(a){if(a instanceof D){o=a.args;continue}throw a}}}throw new s(`${t.kind} is not a callable function`,{fn:t,args:r,env:e})}function re(t,r){const e=he(t.arities,r.length),n=pe(e.params,e.restParam,r,t.env);return K(e.body,n)}function Ke(t,r){return P(t.value.map(e=>x(e,r)))}function Ve(t,r){let e=[];for(const[n,o]of t.entries){const i=x(n,r),a=x(o,r);e.push([i,a])}return L(e)}function Y(t,r){switch(t.kind){case u.vector:case u.list:{const e=y(t);if(e&&t.value.length===2&&S(t.value[0])&&t.value[0].name==="unquote")return x(t.value[1],r);const n=[];for(const o of t.value){if(y(o)&&o.value.length===2&&S(o.value[0])&&o.value[0].name==="unquote-splicing"){const i=x(o.value[1],r);if(!y(i)&&!$(i))throw new s("Unquote-splicing must evaluate to a list or vector",{elem:o,env:r});n.push(...i.value);continue}n.push(Y(o,r))}return e?j(n):P(n)}case u.map:{const e=[];for(const[n,o]of t.entries){const i=Y(n,r),a=Y(o,r);e.push([i,a])}return L(e)}case u.number:case u.string:case u.boolean:case u.keyword:case u.nil:case u.symbol:return t;default:throw new s(`Unexpected form: ${t.kind}`,{form:t,env:r})}}function Qe(t,r,e){switch(t){case"quote":return r.value[1];case"quasiquote":return Y(r.value[1],e);case"def":const n=r.value[1];if(n.kind!=="symbol")throw new s("First element of list must be a symbol",{name:n,list:r,env:e});return _(n.name,x(r.value[2],e),me(e)),E();case"ns":return E();case"if":const o=x(r.value[1],e);return oe(o)?r.value[3]?x(r.value[3],e):E():x(r.value[2],e);case"do":return K(r.value.slice(1),e);case"let":const i=r.value[1];if(!$(i))throw new s("Bindings must be a vector",{bindings:i,env:e});if(i.value.length%2!==0)throw new s("Bindings must be a balanced pair of keys and values",{bindings:i,env:e});const a=r.value.slice(2);let c=e;for(let l=0;l<i.value.length;l+=2){const p=i.value[l];if(!S(p))throw new s("Keys must be symbols",{key:p,env:e});const w=x(i.value[l+1],c);c=O([p.name],[w],c)}return K(a,c);case"fn":{const l=ue(r.value.slice(1),e);return Ne(l,e)}case"defmacro":{const l=r.value[1];if(!S(l))throw new s("First element of defmacro must be a symbol",{name:l,list:r,env:e});const p=ue(r.value.slice(2),e),w=Fe(p,e);return _(l.name,w,de(e)),E()}case"recur":{const l=r.value.slice(1).map(p=>x(p,e));throw new D(l)}case"loop":{const l=r.value[1];if(!$(l))throw new s("loop bindings must be a vector",{loopBindings:l,env:e});if(l.value.length%2!==0)throw new s("loop bindings must be a balanced pair of keys and values",{loopBindings:l,env:e});const p=r.value.slice(2),w=[];let R=e;for(let h=0;h<l.value.length;h+=2){const g=l.value[h];if(!S(g))throw new s("loop binding keys must be symbols",{key:g,env:e});w.push(g.name);const M=x(l.value[h+1],R);R=O([g.name],[M],R)}let k=w.map(h=>W(h,R));for(;;){const h=O(w,k,e);try{return K(p,h)}catch(g){if(g instanceof D){if(g.args.length!==w.length)throw new s(`recur expects ${w.length} arguments but got ${g.args.length}`,{list:r,env:e});k=g.args;continue}throw g}}}default:throw new s(`Unknown special form: ${t}`,{symbol:t,list:r,env:e})}}function Ie(t,r){if(t.value.length===0)throw new s("Unexpected empty list",{list:t,env:r});const e=t.value[0];if(Re(e))return Qe(e.name,t,r);const n=x(e,r);if(ne(n)){const c=t.value.slice(1),l=re(n,c);return x(l,r)}if(Q(n)){const c=t.value.slice(1).map(l=>x(l,r));return I(n,c,r)}if(Z(n)){const c=x(t.value[1],r),l=t.value.length>2?x(t.value[2],r):E();if(U(c)){const p=c.entries.find(([w])=>F(w,n));return p?p[1]:l}return l}if(!S(e))throw new s("First element of list must be a function or special form",{list:t,env:r});const o=e.name,i=W(o,r);if(!Q(i))throw new s(`${o} is not a function`,{list:t,env:r});const a=t.value.slice(1).map(c=>x(c,r));return I(i,a,r)}function x(t,r){switch(t.kind){case u.number:case u.string:case u.keyword:case u.nil:case u.function:case u.boolean:return t;case u.symbol:{const e=t.name.indexOf("/");if(e>0&&e<t.name.length-1){const n=t.name.slice(0,e),o=t.name.slice(e+1),a=me(r).aliases?.get(n);if(!a)throw new s(`No such namespace alias: ${n}`,{symbol:t.name,env:r});return W(o,a)}return W(t.name,r)}case u.vector:return Ke(t,r);case u.map:return Ve(t,r);case u.list:return Ie(t,r);default:throw new s("Unexpected value",{expr:t,env:r})}}function K(t,r){let e=E();for(const n of t)e=x(n,r);return e}function d(t){switch(t.kind){case u.number:return t.value.toString();case u.string:let r="";for(const e of t.value)switch(e){case'"':r+='\\"';break;case"\\":r+="\\\\";break;case`
`:r+="\\n";break;case"\r":r+="\\r";break;case"	":r+="\\t";break;default:r+=e}return`"${r}"`;case u.boolean:return t.value?"true":"false";case u.nil:return"nil";case u.keyword:return`${t.name}`;case u.symbol:return`${t.name}`;case u.list:return`(${t.value.map(d).join(" ")})`;case u.vector:return`[${t.value.map(d).join(" ")}]`;case u.map:return`{${t.entries.map(([e,n])=>`${d(e)} ${d(n)}`).join(" ")}}`;case u.function:{if(t.arities.length===1){const n=t.arities[0];return`(fn [${(n.restParam?[...n.params,{kind:"symbol",name:"&"},n.restParam]:n.params).map(d).join(" ")}] ${n.body.map(d).join(" ")})`}return`(fn ${t.arities.map(n=>`([${(n.restParam?[...n.params,{kind:"symbol",name:"&"},n.restParam]:n.params).map(d).join(" ")}] ${n.body.map(d).join(" ")})`).join(" ")})`}case u.nativeFunction:return`(native-fn ${t.name})`;default:throw new s(`unhandled value type: ${t.kind}`,{value:t})}}function C(t){switch(t.kind){case u.string:return t.value;case u.number:return t.value.toString();case u.boolean:return t.value?"true":"false";case u.keyword:return t.name;case u.symbol:return t.name;case u.list:return`(${t.value.map(C).join(" ")})`;case u.vector:return`[${t.value.map(C).join(" ")}]`;case u.map:return`{${t.entries.map(([r,e])=>`${C(r)} ${C(e)}`).join(" ")}}`;case u.function:{if(t.arities.length===1){const e=t.arities[0];return`(fn [${(e.restParam?[...e.params,{kind:"symbol",name:"&"},e.restParam]:e.params).map(C).join(" ")}] ${e.body.map(C).join(" ")})`}return`(fn ${t.arities.map(e=>`([${(e.restParam?[...e.params,{kind:"symbol",name:"&"},e.restParam]:e.params).map(C).join(" ")}] ${e.body.map(C).join(" ")})`).join(" ")})`}case u.nativeFunction:return`(native-fn ${t.name})`;case u.nil:return"nil";default:throw new s(`unhandled value type: ${t.kind}`,{value:t})}}const N=t=>{if(y(t)||$(t))return t.value;if(U(t))return t.entries.map(([r,e])=>P([r,e]));throw new s(`toSeq expects a collection, got ${d(t)}`,{collection:t})};function We(t){return{list:f("list",(...e)=>e.length===0?j([]):j(e)),vector:f("vector",(...e)=>e.length===0?P([]):P(e)),"hash-map":f("hash-map",(...e)=>{if(e.length===0)return L([]);if(e.length%2!==0)throw new s(`hash-map expects an even number of arguments, got ${e.length}`,{args:e});const n=[];for(let o=0;o<e.length;o+=2){const i=e[o],a=e[o+1];n.push([i,a])}return L(n)}),"+":f("+",(...e)=>{if(e.length===0)return B(0);if(e.some(n=>n.kind!=="number"))throw new s("+ expects all arguments to be numbers",{args:e});return e.reduce((n,o)=>B(n.value+o.value),B(0))}),"-":f("-",(...e)=>{if(e.length===0)throw new s("- expects at least one argument",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("- expects all arguments to be numbers",{args:e});return e.slice(1).reduce((n,o)=>B(n.value-o.value),e[0])}),"*":f("*",(...e)=>{if(e.length===0)return B(1);if(e.some(n=>n.kind!=="number"))throw new s("* expects all arguments to be numbers",{args:e});return e.slice(1).reduce((n,o)=>B(n.value*o.value),e[0])}),"/":f("/",(...e)=>{if(e.length===0)throw new s("/ expects at least one argument",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("/ expects all arguments to be numbers",{args:e});return e.slice(1).reduce((n,o)=>{if(o.value===0)throw new s("division by zero",{args:e});return B(n.value/o.value)},e[0])}),">":f(">",(...e)=>{if(e.length<2)throw new s("> expects at least two arguments",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("> expects all arguments to be numbers",{args:e});for(let n=1;n<e.length;n++)if(e[n].value>=e[n-1].value)return v(!1);return v(!0)}),"<":f("<",(...e)=>{if(e.length<2)throw new s("< expects at least two arguments",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("< expects all arguments to be numbers",{args:e});for(let n=1;n<e.length;n++)if(e[n].value<=e[n-1].value)return v(!1);return v(!0)}),count:f("count",e=>{if(![u.list,u.vector,u.map].includes(e.kind))throw new s(`count expects a countable value, got ${d(e)}`,{countable:e});switch(e.kind){case u.list:return B(e.value.length);case u.vector:return B(e.value.length);case u.map:return B(e.entries.length);default:throw new s(`count expects a countable value, got ${d(e)}`,{countable:e})}}),"truthy?":f("truthy?",e=>v(te(e))),"falsy?":f("falsy?",e=>v(oe(e))),"true?":f("true?",e=>e.kind!=="boolean"?v(!1):v(e.value===!0)),"false?":f("false?",e=>e.kind!=="boolean"?v(!1):v(e.value===!1)),"nil?":f("nil?",e=>v(e.kind==="nil")),not:f("not",e=>v(!te(e))),"=":f("=",(...e)=>{if(e.length<2)throw new s("= expects at least two arguments",{args:e});for(let n=1;n<e.length;n++)if(!F(e[n],e[n-1]))return v(!1);return v(!0)}),first:f("first",e=>{if(!q(e))throw new s("first expects a collection",{collection:e});if(y(e)||$(e))return e.value.length===0?E():e.value[0];if(U(e))return e.entries.length===0?E():P(e.entries[0]);throw new s(`first expects a collection, got ${d(e)}`,{collection:e})}),rest:f("rest",e=>{if(!q(e))throw new s("rest expects a collection",{collection:e});if(y(e))return e.value.length===0?e:j(e.value.slice(1));if($(e))return P(e.value.slice(1));if(U(e))return e.entries.length===0?e:L(e.entries.slice(1));throw new s(`rest expects a collection, got ${d(e)}`,{collection:e})}),conj:f("conj",(e,...n)=>{if(!e)throw new s("conj expects a collection as first argument",{collection:e});if(n.length===0)return e;if(!q(e))throw new s(`conj expects a collection, got ${d(e)}`,{collection:e});if(y(e)){const o=[];for(let i=n.length-1;i>=0;i--)o.push(n[i]);return j([...o,...e.value])}if($(e))return P([...e.value,...n]);if(U(e)){const o=[...e.entries];for(let i=0;i<n.length;i+=1){const a=n[i];if(a.kind!=="vector")throw new s(`conj on maps expects each argument to be a vector key-pair for maps, got ${d(a)}`,{pair:a});if(a.value.length!==2)throw new s(`conj on maps expects each argument to be a vector key-pair for maps, got ${d(a)}`,{pair:a});const c=a.value[0],l=o.findIndex(p=>F(p[0],c));l===-1?o.push([c,a.value[1]]):o[l]=[c,a.value[1]]}return L([...o])}throw new s(`unhandled collection type, got ${d(e)}`,{collection:e})}),cons:f("cons",(e,n)=>{if(!q(n))throw new s(`cons expects a collection as second argument, got ${d(n)}`,{xs:n});if(U(n))throw new s("cons on maps is not supported, use vectors instead",{xs:n});if(y(n))return j([e,...n.value]);if($(n))return P([e,...n.value]);throw new s(`unhandled collection type, got ${d(n)}`,{xs:n})}),assoc:f("assoc",(e,...n)=>{if(!e)throw new s("assoc expects a collection as first argument",{collection:e});if(y(e))throw new s("assoc on lists is not supported, use vectors instead",{collection:e});if(!q(e))throw new s(`assoc expects a collection, got ${d(e)}`,{collection:e});if(n.length<2)throw new s("assoc expects at least two arguments",{args:n});if(n.length%2!==0)throw new s("assoc expects an even number of binding arguments",{args:n});if($(e)){const o=[...e.value];for(let i=0;i<n.length;i+=2){const a=n[i];if(a.kind!=="number")throw new s(`assoc on vectors expects each key argument to be a index (number), got ${d(a)}`,{index:a});if(a.value>o.length)throw new s(`assoc index ${a.value} is out of bounds for vector of length ${o.length}`,{index:a,collection:e});o[a.value]=n[i+1]}return P(o)}if(U(e)){const o=[...e.entries];for(let i=0;i<n.length;i+=2){const a=n[i],c=n[i+1],l=o.findIndex(p=>F(p[0],a));l===-1?o.push([a,c]):o[l]=[a,c]}return L(o)}throw new s(`unhandled collection type, got ${d(e)}`,{collection:e})}),dissoc:f("dissoc",(e,...n)=>{if(!e)throw new s("dissoc expects a collection as first argument",{collection:e});if(y(e))throw new s("dissoc on lists is not supported, use vectors instead",{collection:e});if(!q(e))throw new s(`dissoc expects a collection, got ${d(e)}`,{collection:e});if($(e)){if(e.value.length===0)return e;const o=[...e.value];for(let i=0;i<n.length;i+=1){const a=n[i];if(a.kind!=="number")throw new s(`dissoc on vectors expects each key argument to be a index (number), got ${d(a)}`,{index:a});if(a.value>=o.length)throw new s(`dissoc index ${a.value} is out of bounds for vector of length ${o.length}`,{index:a,collection:e});o.splice(a.value,1)}return P(o)}if(U(e)){if(e.entries.length===0)return e;const o=[...e.entries];for(let i=0;i<n.length;i+=1){const a=n[i],c=o.findIndex(l=>F(l[0],a));if(c===-1)return e;o.splice(c,1)}return L(o)}throw new s(`unhandled collection type, got ${d(e)}`,{collection:e})}),get:f("get",(e,n,o)=>{const i=o??E();switch(e.kind){case u.map:{const a=e.entries;for(const[c,l]of a)if(F(c,n))return l;return i}case u.vector:{const a=e.value;if(n.kind!=="number")throw new s("get on vectors expects a 0-based index as parameter",{key:n});return n.value<0||n.value>=a.length?i:a[n.value]}default:return i}}),str:f("str",(...e)=>Ue(e.map(C).join(""))),map:f("map",(e,n)=>{if(e===void 0)throw new s("map expects a function as first argument, got nil",{fn:e});if(!Q(e))throw new s(`map expects a function as first argument, got ${d(e)}`,{fn:e});if(n===void 0)return E();if(!q(n))throw new s(`map expects a collection, got ${d(n)}`,{collection:n});return($(n)?P:j)(N(n).map(i=>I(e,[i])))}),filter:f("filter",(e,n)=>{if(e===void 0)throw new s("filter expects a function as first argument, got nil",{fn:e});if(!Q(e))throw new s(`filter expects a function as first argument, got ${d(e)}`,{fn:e});if(n===void 0)return E();if(!q(n))throw new s(`filter expects a collection, got ${d(n)}`,{collection:n});return($(n)?P:j)(N(n).filter(i=>te(I(e,[i]))))}),seq:f("seq",e=>{if(e.kind==="nil")return E();if(!q(e))throw new s(`seq expects a collection or nil, got ${d(e)}`,{collection:e});const n=N(e);return n.length===0?E():j(n)}),reduce:f("reduce",(e,...n)=>{if(e===void 0||!Q(e))throw new s(`reduce expects a function as first argument${e!==void 0?`, got ${d(e)}`:""}`,{fn:e});if(n.length===0||n.length>2)throw new s("reduce expects 2 or 3 arguments: (reduce f coll) or (reduce f init coll)",{fn:e});const o=n.length===2,i=o?n[0]:void 0,a=o?n[1]:n[0];if(!q(a))throw new s(`reduce expects a collection, got ${d(a)}`,{collection:a});const c=N(a);if(!o){if(c.length===0)throw new s("reduce called on empty collection with no initial value",{fn:e});if(c.length===1)return c[0];let p=c[0];for(let w=1;w<c.length;w++)p=I(e,[p,c[w]]);return p}let l=i;for(const p of c)l=I(e,[l,p]);return l}),eval:f("eval",e=>{if(e===void 0)throw new s("eval expects a form as argument",{form:e});return x(e,t)}),apply:f("apply",(e,...n)=>{if(e===void 0||!Q(e))throw new s(`apply expects a function as first argument${e!==void 0?`, got ${d(e)}`:""}`,{fn:e});if(n.length===0)throw new s("apply expects at least 2 arguments",{fn:e});const o=n[n.length-1];if(!q(o))throw new s(`apply expects a collection as last argument, got ${d(o)}`,{lastArg:o});const i=[...n.slice(0,-1),...N(o)];return I(e,i)}),">=":f(">=",(...e)=>{if(e.length<2)throw new s(">= expects at least two arguments",{args:e});if(e.some(n=>n.kind!=="number"))throw new s(">= expects all arguments to be numbers",{args:e});for(let n=1;n<e.length;n++)if(e[n].value>e[n-1].value)return v(!1);return v(!0)}),"<=":f("<=",(...e)=>{if(e.length<2)throw new s("<= expects at least two arguments",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("<= expects all arguments to be numbers",{args:e});for(let n=1;n<e.length;n++)if(e[n].value<e[n-1].value)return v(!1);return v(!0)}),inc:f("inc",e=>{if(e===void 0||e.kind!=="number")throw new s(`inc expects a number${e!==void 0?`, got ${d(e)}`:""}`,{x:e});return B(e.value+1)}),dec:f("dec",e=>{if(e===void 0||e.kind!=="number")throw new s(`dec expects a number${e!==void 0?`, got ${d(e)}`:""}`,{x:e});return B(e.value-1)}),max:f("max",(...e)=>{if(e.length===0)throw new s("max expects at least one argument",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("max expects all arguments to be numbers",{args:e});return e.reduce((n,o)=>o.value>n.value?o:n)}),min:f("min",(...e)=>{if(e.length===0)throw new s("min expects at least one argument",{args:e});if(e.some(n=>n.kind!=="number"))throw new s("min expects all arguments to be numbers",{args:e});return e.reduce((n,o)=>o.value<n.value?o:n)}),keys:f("keys",e=>{if(e===void 0||!U(e))throw new s(`keys expects a map${e!==void 0?`, got ${d(e)}`:""}`,{m:e});return P(e.entries.map(([n])=>n))}),vals:f("vals",e=>{if(e===void 0||!U(e))throw new s(`vals expects a map${e!==void 0?`, got ${d(e)}`:""}`,{m:e});return P(e.entries.map(([,n])=>n))}),nth:f("nth",(e,n,o)=>{if(e===void 0||!y(e)&&!$(e))throw new s(`nth expects a list or vector${e!==void 0?`, got ${d(e)}`:""}`,{coll:e});if(n===void 0||n.kind!=="number")throw new s(`nth expects a number index${n!==void 0?`, got ${d(n)}`:""}`,{n});const i=n.value,a=e.value;if(i<0||i>=a.length){if(o!==void 0)return o;throw new s(`nth index ${i} is out of bounds for collection of length ${a.length}`,{coll:e,n})}return a[i]}),take:f("take",(e,n)=>{if(e===void 0||e.kind!=="number")throw new s(`take expects a number as first argument${e!==void 0?`, got ${d(e)}`:""}`,{n:e});if(n===void 0||!q(n))throw new s(`take expects a collection as second argument${n!==void 0?`, got ${d(n)}`:""}`,{coll:n});const o=e.value;return o<=0?j([]):j(N(n).slice(0,o))}),drop:f("drop",(e,n)=>{if(e===void 0||e.kind!=="number")throw new s(`drop expects a number as first argument${e!==void 0?`, got ${d(e)}`:""}`,{n:e});if(n===void 0||!q(n))throw new s(`drop expects a collection as second argument${n!==void 0?`, got ${d(n)}`:""}`,{coll:n});const o=e.value;return o<=0?j(N(n)):j(N(n).slice(o))}),concat:f("concat",(...e)=>{const n=[];for(const o of e){if(!q(o))throw new s(`concat expects collections, got ${d(o)}`,{coll:o});n.push(...N(o))}return j(n)}),into:f("into",(e,n)=>{if(e===void 0||!q(e))throw new s(`into expects a collection as first argument${e!==void 0?`, got ${d(e)}`:""}`,{to:e});if(n===void 0||!q(n))throw new s(`into expects a collection as second argument${n!==void 0?`, got ${d(n)}`:""}`,{from:n});let o=e;for(const i of N(n))if(y(o))o=j([i,...o.value]);else if($(o))o=P([...o.value,i]);else if(U(o)){const a=i;if(a.kind!=="vector"||a.value.length!==2)throw new s(`into on a map expects each source element to be a [k v] vector, got ${d(a)}`,{pair:a});const[c,l]=a.value,p=[...o.entries],w=p.findIndex(R=>F(R[0],c));w===-1?p.push([c,l]):p[w]=[c,l],o=L(p)}return o}),zipmap:f("zipmap",(e,n)=>{if(e===void 0||!q(e))throw new s(`zipmap expects a collection as first argument${e!==void 0?`, got ${d(e)}`:""}`,{ks:e});if(n===void 0||!q(n))throw new s(`zipmap expects a collection as second argument${n!==void 0?`, got ${d(n)}`:""}`,{vs:n});const o=N(e),i=N(n),a=Math.min(o.length,i.length),c=[];for(let l=0;l<a;l++)c.push([o[l],i[l]]);return L(c)}),"number?":f("number?",e=>v(e!==void 0&&e.kind==="number")),"string?":f("string?",e=>v(e!==void 0&&e.kind==="string")),"boolean?":f("boolean?",e=>v(e!==void 0&&e.kind==="boolean")),"vector?":f("vector?",e=>v(e!==void 0&&$(e))),"list?":f("list?",e=>v(e!==void 0&&y(e))),"map?":f("map?",e=>v(e!==void 0&&U(e))),"keyword?":f("keyword?",e=>v(e!==void 0&&Z(e))),"symbol?":f("symbol?",e=>v(e!==void 0&&S(e))),"fn?":f("fn?",e=>v(e!==void 0&&Q(e))),"coll?":f("coll?",e=>v(e!==void 0&&q(e))),"macroexpand-1":f("macroexpand-1",e=>{if(!y(e)||e.value.length===0)return e;const n=e.value[0];if(!S(n))return e;let o;try{o=W(n.name,t)}catch{return e}return ne(o)?re(o,e.value.slice(1)):e}),macroexpand:f("macroexpand",e=>{let n=e;for(;;){if(!y(n)||n.value.length===0)return n;const o=n.value[0];if(!S(o))return n;let i;try{i=W(o.name,t)}catch{return n}if(!ne(i))return n;n=re(i,n.value.slice(1))}}),type:f("type",e=>{if(e===void 0)throw new s("type expects an argument",{x:e});const o={number:":number",string:":string",boolean:":boolean",nil:":nil",keyword:":keyword",symbol:":symbol",list:":list",vector:":vector",map:":map",function:":function","native-function":":function"}[e.kind];if(!o)throw new s(`type: unhandled kind ${e.kind}`,{x:e});return Be(o)}),repeat:f("repeat",(e,n)=>{if(e===void 0||e.kind!=="number")throw new s(`repeat expects a number as first argument${e!==void 0?`, got ${d(e)}`:""}`,{n:e});return j(Array(e.value).fill(n))})}}function _e(t,r){const e=We(t);for(const[n,o]of Object.entries(e))_(n,o,t);r&&_("println",f("println",(...n)=>{const o=n.map(C).join(" ");return r(o),E()}),t)}const Te=(t,r,e)=>({line:t,col:r,offset:e});class ee extends Error{context;constructor(r,e){super(r),this.name="TokenizerError",this.context=e}}const Oe=t=>t===`
`,G=t=>[" ",",",`
`,"\r","	"].includes(t),ie=t=>t===";",we=t=>t==="(",ve=t=>t===")",ke=t=>t==="[",ge=t=>t==="]",be=t=>t==="{",ye=t=>t==="}",ze=t=>t==='"',$e=t=>t==="'",xe=t=>t==="`",De=t=>t==="~",He=t=>t==="@",z=t=>{const r=parseInt(t);return isNaN(r)?!1:r>=0&&r<=9},Ge=t=>t===".",qe=t=>t===":",se=t=>we(t)||ve(t)||ke(t)||ge(t)||be(t)||ye(t)||xe(t)||$e(t),Je=t=>{const r=t.position();return t.consumeWhile(G),{kind:m.Whitespace,start:r,end:t.position()}},Xe=t=>{const r=t.position();t.advance();const e=t.consumeWhile(n=>!Oe(n));return!t.isAtEnd()&&t.peek()===`
`&&t.advance(),{kind:m.Comment,value:e,start:r,end:t.position()}},Ye=t=>{const r=t.position();t.advance();const e=[];let n=!1;for(;!t.isAtEnd();){const o=t.peek();if(o==="\\"){t.advance();const i=t.peek();switch(i){case'"':e.push('"');break;case"\\":e.push("\\");break;case"n":e.push(`
`);break;case"r":e.push("\r");break;case"t":e.push("	");break;default:e.push(i)}t.isAtEnd()||t.advance();continue}if(o==='"'){t.advance(),n=!0;break}e.push(t.advance())}if(!n)throw new ee(`Unterminated string detected at ${r.offset}`,t.position());return{kind:m.String,value:e.join(""),start:r,end:t.position()}},Ze=t=>{const r=t.position(),e=t.consumeWhile(n=>qe(n)||!G(n)&&!se(n)&&!ie(n));return{kind:m.Keyword,value:e,start:r,end:t.position()}},et=t=>{const r=t.position();let e="";if(t.peek()==="-"&&(e+=t.advance()),e+=t.consumeWhile(z),!t.isAtEnd()&&t.peek()==="."&&t.peek(1)!==null&&z(t.peek(1))&&(e+=t.advance(),e+=t.consumeWhile(z)),!t.isAtEnd()&&Ge(t.peek()))throw new ee(`Invalid number format at line ${r.line} column ${r.col}: "${e}${t.consumeWhile(n=>!G(n)&&!se(n))}"`,{start:r,end:t.position()});return{kind:m.Number,value:Number(e),start:r,end:t.position()}},tt=t=>{const r=t.position(),e=t.consumeWhile(n=>!G(n)&&!se(n)&&!ie(n));return{kind:m.Symbol,value:e,start:r,end:t.position()}};function nt(t){const r=t.peek();if(G(t.peek()))return Je(t);if(ie(t.peek()))return Xe(t);if(we(r)){const e=t.position();return t.advance(),{kind:m.LParen,value:A.LParen,start:e,end:t.position()}}if(ve(r)){const e=t.position();return t.advance(),{kind:m.RParen,value:A.RParen,start:e,end:t.position()}}if(ke(r)){const e=t.position();return t.advance(),{kind:m.LBracket,value:A.LBracket,start:e,end:t.position()}}if(ge(r)){const e=t.position();return t.advance(),{kind:m.RBracket,value:A.RBracket,start:e,end:t.position()}}if(be(r)){const e=t.position();return t.advance(),{kind:m.LBrace,value:A.LBrace,start:e,end:t.position()}}if(ye(r)){const e=t.position();return t.advance(),{kind:m.RBrace,value:A.RBrace,start:e,end:t.position()}}if(ze(r))return Ye(t);if(qe(r))return Ze(t);if(z(r)||r==="-"&&t.peek(1)!==null&&z(t.peek(1)))return et(t);if($e(r)){const e=t.position();return t.advance(),{kind:m.Quote,value:A.Quote,start:e,end:t.position()}}if(xe(r)){const e=t.position();return t.advance(),{kind:m.Quasiquote,value:A.Quasiquote,start:e,end:t.position()}}if(De(r)){const e=t.position();t.advance();const n=t.peek();if(!n)throw new ee(`Unexpected end of input while parsing unquote at ${e.offset}`,e);return He(n)?(t.advance(),{kind:m.UnquoteSplicing,value:A.UnquoteSplicing,start:e,end:t.position()}):{kind:m.Unquote,value:A.Unquote,start:e,end:t.position()}}return tt(t)}function rt(t){const r=[];let e;try{for(;!t.isAtEnd();){const o=nt(t);if(!o)break;o.kind!==m.Whitespace&&r.push(o)}}catch(o){e=o}return{tokens:r,scanner:t,error:e}}function ot(t){const r=Te(0,0,0),e={peek:(n=0)=>{const o=r.offset+n;return o>=t.length?null:t[o]},advance:()=>{if(r.offset>=t.length)return null;const n=t[r.offset];return r.offset++,n===`
`?(r.line++,r.col=0):r.col++,n},isAtEnd:()=>r.offset>=t.length,position:()=>({line:r.line,col:r.col,offset:r.offset}),consumeWhile(n){const o=[];for(;!e.isAtEnd()&&n(e.peek());)o.push(e.advance());return o.join("")}};return e}function ce(t){const r=t.length,e=ot(t),n=rt(e);if(n.error)throw n.error;if(n.scanner.position().offset!==r)throw new ee(`Unexpected end of input, expected ${r} characters, got ${n.scanner.position().offset}`,n.scanner.position());return n.tokens}function T(t){return"value"in t?t.value:""}function it(t){let r=0;const e={peek:(n=0)=>{const o=r+n;return o>=t.length?null:t[o]},advance:()=>{if(r>=t.length)return null;const n=t[r];return r++,n},isAtEnd:()=>r>=t.length,position:()=>({offset:r}),consumeWhile(n){const o=[];for(;!e.isAtEnd()&&n(e.peek());)o.push(e.advance());return o},consumeN(n){for(let o=0;o<n;o++)e.advance()}};return e}class b extends Error{context;constructor(r,e){super(r),this.name="ParserError",this.context=e}}function st(t){const r=t.peek();if(!r)throw new b("Unexpected end of input",t.position());switch(r.kind){case m.Symbol:return mt(t);case m.String:return t.advance(),{kind:"string",value:r.value};case m.Number:return t.advance(),{kind:"number",value:r.value};case m.Keyword:return t.advance(),{kind:"keyword",name:r.value}}throw new b(`Unexpected token: ${r.kind}`,r)}const at=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input while parsing quote",t.position());t.advance();const e=V(t);if(!e)throw new b(`Unexpected token: ${T(r)}`,r);return{kind:u.list,value:[H("quote"),e]}},ut=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input while parsing quasiquote",t.position());t.advance();const e=V(t);if(!e)throw new b(`Unexpected token: ${T(r)}`,r);return{kind:u.list,value:[H("quasiquote"),e]}},ct=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input while parsing unquote",t.position());t.advance();const e=V(t);if(!e)throw new b(`Unexpected token: ${T(r)}`,r);return{kind:u.list,value:[H("unquote"),e]}},lt=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input while parsing unquote splicing",t.position());t.advance();const e=V(t);if(!e)throw new b(`Unexpected token: ${T(r)}`,r);return{kind:u.list,value:[H("unquote-splicing"),e]}},Ee=t=>[m.RParen,m.RBracket,m.RBrace].includes(t.kind),Se=(t,r,e)=>{const n=t.peek();if(!n)throw new b("Unexpected end of input while parsing collection",t.position());t.advance();const o=[];let i=!1;for(;!t.isAtEnd();){const a=t.peek();if(!a)break;if(Ee(a)&&a.kind!==e)throw new b(`Expected '${e}' to close ${r} started at line ${n.start.line} column ${n.start.col}, but got '${T(a)}' at line ${a.start.line} column ${a.start.col}`,a);if(a.kind===e){t.advance(),i=!0;break}const c=V(t);o.push(c)}if(!i)throw new b(`Unmatched ${r} started at line ${n.start.line} column ${n.start.col}`,t.peek());return{kind:r,value:o}},ft=t=>Se(t,u.list,m.RParen),dt=t=>Se(t,u.vector,m.RBracket),mt=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input",t.position());if(r.kind!==m.Symbol)throw new b(`Unexpected token: ${T(r)}`,r);switch(t.advance(),r.value){case"true":case"false":return v(r.value==="true");case"nil":return E();default:return H(r.value)}},pt=t=>{const r=t.peek();if(!r)throw new b("Unexpected end of input while parsing map",t.position());let e=!1;t.advance();const n=[];for(;!t.isAtEnd();){const o=t.peek();if(!o)break;if(Ee(o)&&o.kind!==m.RBrace)throw new b(`Expected '}' to close map started at line ${r.start.line} column ${r.start.col}, but got '${o.kind}' at line ${o.start.line} column ${o.start.col}`,o);if(o.kind===m.RBrace){t.advance(),e=!0;break}const i=V(t),a=t.peek();if(!a)throw new b(`Expected value in map started at line ${r.start.line} column ${r.start.col}, but got end of input`,t.position());if(a.kind===m.RBrace)throw new b(`Map started at line ${r.start.line} column ${r.start.col} has key ${i.kind} but no value`,t.position());const c=V(t);if(!c)break;n.push([i,c])}if(!e)throw new b(`Unmatched map started at line ${r.start.line} column ${r.start.col}`,t.peek());return{kind:u.map,entries:n}};function V(t){const r=t.peek();if(!r)throw new b("Unexpected end of input",t.position());switch(r.kind){case m.String:case m.Number:case m.Keyword:case m.Symbol:return st(t);case m.LParen:return ft(t);case m.LBrace:return pt(t);case m.LBracket:return dt(t);case m.Quote:return at(t);case m.Quasiquote:return ut(t);case m.Unquote:return ct(t);case m.UnquoteSplicing:return lt(t);default:throw new b(`Unexpected token: ${T(r)} at line ${r.start.line} column ${r.start.col}`,r)}}function le(t){const r=t.filter(o=>o.kind!==m.Comment),e=it(r),n=[];for(;!e.isAtEnd();)n.push(V(e));return n}function ht(t){const r=je(t);if(!r)return null;const e=r.value[1];return S(e)?e.name:null}function je(t){const r=t.find(e=>y(e)&&S(e.value[0])&&e.value[0].name==="ns");return!r||!y(r)?null:r}function wt(t){const r=je(t);if(!r)return[];const e=[];for(let n=2;n<r.value.length;n++){const o=r.value[n];y(o)&&Z(o.value[0])&&o.value[0].name===":require"&&e.push(o.value.slice(1))}return e}function fe(t,r,e,n){if(!$(t))throw new s("require spec must be a vector, e.g. [my.ns :as alias]",{spec:t});const o=t.value;if(o.length===0||!S(o[0]))throw new s("First element of require spec must be a namespace symbol",{spec:t});const i=o[0].name;let a=e.get(i);if(!a&&n&&(n(i),a=e.get(i)),!a)throw new s(`Namespace ${i} not found. Only already-loaded namespaces can be required.`,{nsName:i});let c=1;for(;c<o.length;){const l=o[c];if(!Z(l))throw new s(`Expected keyword in require spec, got ${l.kind}`,{spec:t,position:c});if(l.name===":as"){c++;const p=o[c];if(!p||!S(p))throw new s(":as expects a symbol alias",{spec:t,position:c});r.aliases||(r.aliases=new Map),r.aliases.set(p.name,a),c++}else if(l.name===":refer"){c++;const p=o[c];if(!p||!$(p))throw new s(":refer expects a vector of symbols",{spec:t,position:c});for(const w of p.value){if(!S(w))throw new s(":refer vector must contain only symbols",{spec:t,sym:w});let R;try{R=W(w.name,a)}catch{throw new s(`Symbol ${w.name} not found in namespace ${i}`,{nsName:i,symbol:w.name})}_(w.name,R,r)}c++}else throw new s(`Unknown require option ${l.name}. Supported: :as, :refer`,{spec:t,keyword:l.name})}}function gt(t){const r=new Map,e=X();e.namespace="clojure.core",_e(e,t?.output),r.set("clojure.core",e);const n=X(e);n.namespace="user",r.set("user",n);let o="user";const i=t?.readFile&&t?.sourceRoots?k=>{for(const h of t.sourceRoots){const g=`${h.replace(/\/$/,"")}/${k.replace(/\./g,"/")}.clj`;try{const M=t.readFile(g);if(M)return w(M),!0}catch{continue}}return!1}:void 0;function a(k){if(!r.has(k)){const h=X(e);h.namespace=k,r.set(k,h)}return r.get(k)}function c(k){a(k),o=k}function l(k){return r.get(k)??null}_("require",f("require",(...k)=>{const h=r.get(o);for(const g of k)fe(g,h,r,i);return E()}),e);function p(k,h){const g=wt(k);for(const M of g)for(const J of M)fe(J,h,r,i)}function w(k,h){const g=le(ce(k)),M=ht(g)??h??"user",J=a(M);p(g,J),K(g,J)}for(const k of t?.entries??[])w(k);return{registry:r,get currentNs(){return o},setNs:c,getNs:l,loadFile:w,evaluate(k){try{const h=le(ce(k)),g=l(o);return p(h,g),K(h,g)}catch(h){throw h instanceof D?new s("recur called outside of loop or fn",{args:h.args}):h}},evaluateForms(k){try{return K(k,l(o))}catch(h){throw h instanceof D?new s("recur called outside of loop or fn",{args:h.args}):h}}}}export{s as E,I as a,E as b,gt as c,P as d,Be as e,L as f,f as g,v as h,kt as i,Ue as j,B as k,vt as m,d as p,ce as t};
